<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font: 12px sans-serif;
      margin: 20px;
      color: #333;
    }
    #frames-list {
      margin: 10px 0;
      border: 1px solid #e5e5e5;
      border-radius: 4px;
      padding: 8px;
      min-height: 100px;
      max-height: 200px;
      overflow-y: auto;
    }
    .frame-item {
      padding: 8px;
      margin: 4px 0;
      background: #f5f5f5;
      border-radius: 4px;
    }
    .frame-name {
      font-weight: bold;
    }
    .frame-size {
      color: #666;
      font-size: 11px;
    }
    button {
      background: #18A0FB;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin: 4px 0;
      width: 100%;
    }
    button:disabled {
      background: #ccc;
    }
    #status {
      margin-top: 10px;
      color: #666;
    }
    .error {
      color: red;
    }
    #preview {
      margin: 10px 0;
      text-align: center;
    }
    #preview img {
      max-width: 100%;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .download-link {
      display: inline-block;
      margin-top: 8px;
      color: #18A0FB;
      text-decoration: none;
      padding: 4px 8px;
      background: #E8F3FF;
      border-radius: 4px;
    }
    .frame-item.dragging {
      opacity: 0.5;
      background: #e8f0fe;
    }
    .frame-item {
      transition: transform 0.2s ease;
    }
    .frame-item:hover {
      transform: translateX(4px);
    }
    .export-options {
      margin: 10px 0;
      padding: 10px;
      border: 1px solid #e5e5e5;
      border-radius: 4px;
    }
    .export-option {
      display: flex;
      align-items: center;
      margin: 8px 0;
    }
    .export-option input[type="radio"] {
      margin-right: 8px;
    }
    .format-settings {
      margin-top: 8px;
      padding-left: 24px;
    }
    .format-settings.hidden {
      display: none;
    }
  </style>
  <script>
    // gif.js 0.2.0 - https://github.com/jnordberg/gif.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GIF=f()}})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){function EventEmitter(){this._events=this._events||{};this._maxListeners=this._maxListeners||undefined}module.exports=EventEmitter;EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;EventEmitter.defaultMaxListeners=10;EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||n<0||isNaN(n))throw TypeError("n must be a positive number");this._maxListeners=n;return this};EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(!this._events)this._events={};if(type==="error"){if(!this._events.error||isObject(this._events.error)&&!this._events.error.length){er=arguments[1];if(er instanceof Error){throw er}else{var err=new Error('Uncaught, unspecified "error" event. ('+er+")");err.context=er;throw err}}}handler=this._events[type];if(isUndefined(handler))return false;if(isFunction(handler)){switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:args=Array.prototype.slice.call(arguments,1);handler.apply(this,args)}}else if(isObject(handler)){args=Array.prototype.slice.call(arguments,1);listeners=handler.slice();len=listeners.length;for(i=0;i<len;i++)listeners[i].apply(this,args)}return true};EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events)this._events={};if(this._events.newListener)this.emit("newListener",type,isFunction(listener.listener)?listener.listener:listener);if(!this._events[type])this._events[type]=listener;else if(isObject(this._events[type]))this._events[type].push(listener);else this._events[type]=[this._events[type],listener];if(isObject(this._events[type])&&!this._events[type].warned){if(!isUndefined(this._maxListeners)){m=this._maxListeners}else{m=EventEmitter.defaultMaxListeners}if(m&&m>0&&this._events[type].length>m){this._events[type].warned=true;console.error("(node) warning: possible EventEmitter memory "+"leak detected. %d listeners added. "+"Use emitter.setMaxListeners() to increase limit.",this._events[type].length);if(typeof console.trace==="function"){console.trace()}}}return this};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.once=function(type,listener){if(!isFunction(listener))throw TypeError("listener must be a function");var fired=false;function g(){this.removeListener(type,g);if(!fired){fired=true;listener.apply(this,arguments)}}g.listener=listener;this.on(type,g);return this};EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events||!this._events[type])return this;list=this._events[type];length=list.length;position=-1;if(list===listener||isFunction(list.listener)&&list.listener===listener){delete this._events[type];if(this._events.removeListener)this.emit("removeListener",type,listener)}else if(isObject(list)){for(i=length;i-- >0;){if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}}if(position<0)return this;if(list.length===1){list.length=0;delete this._events[type]}else{list.splice(position,1)}if(this._events.removeListener)this.emit("removeListener",type,listener)}return this};EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener){if(arguments.length===0)this._events={};else if(this._events[type])delete this._events[type];return this}if(arguments.length===0){for(key in this._events){if(key==="removeListener")continue;this.removeAllListeners(key)}this.removeAllListeners("removeListener");this._events={};return this}listeners=this._events[type];if(isFunction(listeners)){this.removeListener(type,listeners)}else if(listeners){while(listeners.length)this.removeListener(type,listeners[listeners.length-1])}delete this._events[type];return this};EventEmitter.prototype.listeners=function(type){var ret;if(!this._events||!this._events[type])ret=[];else if(isFunction(this._events[type]))ret=[this._events[type]];else ret=this._events[type].slice();return ret};EventEmitter.prototype.listenerCount=function(type){if(this._events){var evlistener=this._events[type];if(isFunction(evlistener))return 1;else if(evlistener)return evlistener.length}return 0};EventEmitter.listenerCount=function(emitter,type){return emitter.listenerCount(type)};function isFunction(arg){return typeof arg==="function"}function isNumber(arg){return typeof arg==="number"}function isObject(arg){return typeof arg==="object"&&arg!==null}function isUndefined(arg){return arg===void 0}},{}],2:[function(require,module,exports){var UA,browser,mode,platform,ua;ua=navigator.userAgent.toLowerCase();platform=navigator.platform.toLowerCase();UA=ua.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/)||[null,"unknown",0];mode=UA[1]==="ie"&&document.documentMode;browser={name:UA[1]==="version"?UA[3]:UA[1],version:mode||parseFloat(UA[1]==="opera"&&UA[4]?UA[4]:UA[2]),platform:{name:ua.match(/ip(?:ad|od|hone)/)?"ios":(ua.match(/(?:webos|android)/)||platform.match(/mac|win|linux/)||["other"])[0]}};browser[browser.name]=true;browser[browser.name+parseInt(browser.version,10)]=true;browser.platform[browser.platform.name]=true;module.exports=browser},{}],3:[function(require,module,exports){var EventEmitter,GIF,browser,extend=function(child,parent){for(var key in parent){if(hasProp.call(parent,key))child[key]=parent[key]}function ctor(){this.constructor=child}ctor.prototype=parent.prototype;child.prototype=new ctor;child.__super__=parent.prototype;return child},hasProp={}.hasOwnProperty,indexOf=[].indexOf||function(item){for(var i=0,l=this.length;i<l;i++){if(i in this&&this[i]===item)return i}return-1},slice=[].slice;EventEmitter=require("events").EventEmitter;browser=require("./browser.coffee");GIF=function(superClass){var defaults,frameDefaults;extend(GIF,superClass);defaults={workerScript:"gif.worker.js",workers:2,repeat:0,background:"#fff",quality:10,width:null,height:null,transparent:null,debug:false,dither:false};frameDefaults={delay:500,copy:false};function GIF(options){var base,key,value;this.running=false;this.options={};this.frames=[];this.freeWorkers=[];this.activeWorkers=[];this.setOptions(options);for(key in defaults){value=defaults[key];if((base=this.options)[key]==null){base[key]=value}}}GIF.prototype.setOption=function(key,value){this.options[key]=value;if(this._canvas!=null&&(key==="width"||key==="height")){return this._canvas[key]=value}};GIF.prototype.setOptions=function(options){var key,results,value;results=[];for(key in options){if(!hasProp.call(options,key))continue;value=options[key];results.push(this.setOption(key,value))}return results};GIF.prototype.addFrame=function(image,options){var frame,key;if(options==null){options={}}frame={};frame.transparent=this.options.transparent;for(key in frameDefaults){frame[key]=options[key]||frameDefaults[key]}if(this.options.width==null){this.setOption("width",image.width)}if(this.options.height==null){this.setOption("height",image.height)}if(typeof ImageData!=="undefined"&&ImageData!==null&&image instanceof ImageData){frame.data=image.data}else if(typeof CanvasRenderingContext2D!=="undefined"&&CanvasRenderingContext2D!==null&&image instanceof CanvasRenderingContext2D||typeof WebGLRenderingContext!=="undefined"&&WebGLRenderingContext!==null&&image instanceof WebGLRenderingContext){if(options.copy){frame.data=this.getContextData(image)}else{frame.context=image}}else if(image.childNodes!=null){if(options.copy){frame.data=this.getImageData(image)}else{frame.image=image}}else{throw new Error("Invalid image")}return this.frames.push(frame)};GIF.prototype.render=function(){var i,j,numWorkers,ref;if(this.running){throw new Error("Already running")}if(this.options.width==null||this.options.height==null){throw new Error("Width and height must be set prior to rendering")}this.running=true;this.nextFrame=0;this.finishedFrames=0;this.imageParts=function(){var j,ref,results;results=[];for(i=j=0,ref=this.frames.length;0<=ref?j<ref:j>ref;i=0<=ref?++j:--j){results.push(null)}return results}.call(this);numWorkers=this.spawnWorkers();if(this.options.globalPalette===true){this.renderNextFrame()}else{for(i=j=0,ref=numWorkers;0<=ref?j<ref:j>ref;i=0<=ref?++j:--j){this.renderNextFrame()}}this.emit("start");return this.emit("progress",0)};GIF.prototype.abort=function(){var worker;while(true){worker=this.activeWorkers.shift();if(worker==null){break}this.log("killing active worker");worker.terminate()}this.running=false;return this.emit("abort")};GIF.prototype.spawnWorkers=function(){var j,numWorkers,ref,results;numWorkers=Math.min(this.options.workers,this.frames.length);(function(){results=[];for(var j=ref=this.freeWorkers.length;ref<=numWorkers?j<numWorkers:j>numWorkers;ref<=numWorkers?j++:j--){results.push(j)}return results}).apply(this).forEach(function(_this){return function(i){var worker;_this.log("spawning worker "+i);worker=new Worker(_this.options.workerScript);worker.onmessage=function(event){_this.activeWorkers.splice(_this.activeWorkers.indexOf(worker),1);_this.freeWorkers.push(worker);return _this.frameFinished(event.data)};return _this.freeWorkers.push(worker)}}(this));return numWorkers};GIF.prototype.frameFinished=function(frame){var i,j,ref;this.log("frame "+frame.index+" finished - "+this.activeWorkers.length+" active");this.finishedFrames++;this.emit("progress",this.finishedFrames/this.frames.length);this.imageParts[frame.index]=frame;if(this.options.globalPalette===true){this.options.globalPalette=frame.globalPalette;this.log("global palette analyzed");if(this.frames.length>2){for(i=j=1,ref=this.freeWorkers.length;1<=ref?j<ref:j>ref;i=1<=ref?++j:--j){this.renderNextFrame()}}}if(indexOf.call(this.imageParts,null)>=0){return this.renderNextFrame()}else{return this.finishRendering()}};GIF.prototype.finishRendering=function(){var data,frame,i,image,j,k,l,len,len1,len2,len3,offset,page,ref,ref1,ref2;len=0;ref=this.imageParts;for(j=0,len1=ref.length;j<len1;j++){frame=ref[j];len+=(frame.data.length-1)*frame.pageSize+frame.cursor}len+=frame.pageSize-frame.cursor;this.log("rendering finished - filesize "+Math.round(len/1e3)+"kb");data=new Uint8Array(len);offset=0;ref1=this.imageParts;for(k=0,len2=ref1.length;k<len2;k++){frame=ref1[k];ref2=frame.data;for(i=l=0,len3=ref2.length;l<len3;i=++l){page=ref2[i];data.set(page,offset);if(i===frame.data.length-1){offset+=frame.cursor}else{offset+=frame.pageSize}}}image=new Blob([data],{type:"image/gif"});return this.emit("finished",image,data)};GIF.prototype.renderNextFrame=function(){var frame,task,worker;if(this.freeWorkers.length===0){throw new Error("No free workers")}if(this.nextFrame>=this.frames.length){return}frame=this.frames[this.nextFrame++];worker=this.freeWorkers.shift();task=this.getTask(frame);this.log("starting frame "+(task.index+1)+" of "+this.frames.length);this.activeWorkers.push(worker);return worker.postMessage(task)};GIF.prototype.getContextData=function(ctx){return ctx.getImageData(0,0,this.options.width,this.options.height).data};GIF.prototype.getImageData=function(image){var ctx;if(this._canvas==null){this._canvas=document.createElement("canvas");this._canvas.width=this.options.width;this._canvas.height=this.options.height}ctx=this._canvas.getContext("2d");ctx.setFill=this.options.background;ctx.fillRect(0,0,this.options.width,this.options.height);ctx.drawImage(image,0,0);return this.getContextData(ctx)};GIF.prototype.getTask=function(frame){var index,task;index=this.frames.indexOf(frame);task={index:index,last:index===this.frames.length-1,delay:frame.delay,transparent:frame.transparent,width:this.options.width,height:this.options.height,quality:this.options.quality,dither:this.options.dither,globalPalette:this.options.globalPalette,repeat:this.options.repeat,canTransfer:browser.name==="chrome"};if(frame.data!=null){task.data=frame.data}else if(frame.context!=null){task.data=this.getContextData(frame.context)}else if(frame.image!=null){task.data=this.getImageData(frame.image)}else{throw new Error("Invalid frame")}return task};GIF.prototype.log=function(){var args;args=1<=arguments.length?slice.call(arguments,0):[];if(!this.options.debug){return}return console.log.apply(console,args)};return GIF}(EventEmitter);module.exports=GIF},{"./browser.coffee":2,events:1}]},{},[3])(3)});
//# sourceMappingURL=gif.js.map
  </script>
  <script>
    let selectedFrames = [];
    
    function updateStatus(msg, isError) {
      const status = document.getElementById('status');
      if (status) {
        status.textContent = msg;
        status.className = isError ? 'error' : '';
      }
      console.log('Status updated:', msg, isError ? '(error)' : '');
    }

    function updateFramesList(frames) {
      console.log('updateFramesList called with frames:', frames);
      
      selectedFrames = frames || [];
      const list = document.getElementById('frames-list');
      const convert = document.getElementById('convert');
      
      if (!list || !convert) {
        console.error('Required elements not found');
        return;
      }
      
      list.innerHTML = '';
      
      if (!frames || !Array.isArray(frames) || frames.length === 0) {
        console.log('No valid frames to display');
        list.innerHTML = '<div class="frame-item">No frames selected</div>';
        convert.disabled = true;
        updateStatus('No frames selected');
        return;
      }

      // Create a container for sortable frames
      const sortableList = document.createElement('div');
      sortableList.id = 'sortable-frames';
      sortableList.style.display = 'flex';
      sortableList.style.flexDirection = 'column';
      sortableList.style.gap = '8px';
      list.appendChild(sortableList);
      
      frames.forEach((frame, index) => {
        console.log(`Processing frame ${index}:`, frame);
        
        if (!frame || !frame.id || !frame.name) {
          console.error('Invalid frame data:', frame);
          return;
        }

        const div = document.createElement('div');
        div.className = 'frame-item';
        div.draggable = true;
        div.dataset.frameId = frame.id;
        div.dataset.index = index;
        div.style.cursor = 'move';
        div.innerHTML = `
          <div style="display: flex; align-items: center; gap: 8px;">
            <div style="color: #666; user-select: none;">☰</div>
            <div>
              <div class="frame-name">${frame.name}</div>
              <div class="frame-size">${frame.width} × ${frame.height}</div>
            </div>
          </div>
        `;

        // Add drag event listeners
        div.addEventListener('dragstart', (e) => {
          e.target.classList.add('dragging');
          e.dataTransfer.setData('text/plain', index);
        });

        div.addEventListener('dragend', (e) => {
          e.target.classList.remove('dragging');
        });

        sortableList.appendChild(div);
      });

      // Add drag and drop event listeners to the container
      sortableList.addEventListener('dragover', (e) => {
        e.preventDefault();
        const draggingItem = sortableList.querySelector('.dragging');
        const siblings = [...sortableList.querySelectorAll('.frame-item:not(.dragging)')];
        const nextSibling = siblings.find(sibling => {
          const box = sibling.getBoundingClientRect();
          return e.clientY <= box.top + box.height / 2;
        });
        
        if (nextSibling) {
          sortableList.insertBefore(draggingItem, nextSibling);
        } else {
          sortableList.appendChild(draggingItem);
        }
      });

      sortableList.addEventListener('drop', (e) => {
        e.preventDefault();
        // Update the selectedFrames array based on the new order
        const newOrder = [...sortableList.querySelectorAll('.frame-item')].map(item => {
          const frameId = item.dataset.frameId;
          return selectedFrames.find(frame => frame.id === frameId);
        });
        selectedFrames = newOrder;
      });

      convert.disabled = false;
      updateStatus(`${frames.length} frame(s) selected`);
    }

    async function createGif(frames) {
      try {
        updateStatus('Creating GIF...');
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const frameDelay = parseInt(document.getElementById('frameDelay').value) || 500;
        
        // Load all images first
        const images = await Promise.all(frames.map((frame, index) => {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error(`Failed to load frame ${index + 1}`));
            img.src = 'data:image/png;base64,' + frame;
          });
        }));
        
        if (images.length === 0) {
          throw new Error('No frames loaded');
        }

        // Set canvas size to first frame
        canvas.width = images[0].width;
        canvas.height = images[0].height;
        
        // Create GIF with optimized settings
        const gif = new GIF({
          workers: 2, // Increase worker count for better performance
          quality: 5, // Lower quality for smoother animation
          width: canvas.width,
          height: canvas.height,
          transparent: 'rgba(0,0,0,0)',
          background: null,
          dither: false, // Disable dithering for smoother color transitions
          workerScript: URL.createObjectURL(new Blob([`
            function ByteArray() {
              this.page = -1;
              this.pages = [];
              this.newPage();
            }
            
            ByteArray.pageSize = 4096;
            ByteArray.charMap = {};
            
            for (var i = 0; i < 256; i++) {
              ByteArray.charMap[i] = String.fromCharCode(i);
            }
            
            ByteArray.prototype.newPage = function() {
              this.pages[++this.page] = new Uint8Array(ByteArray.pageSize);
              this.cursor = 0;
            };
            
            ByteArray.prototype.getData = function() {
              var rv = "";
              for (var p = 0; p < this.pages.length; p++) {
                for (var i = 0; i < ByteArray.pageSize; i++) {
                  rv += ByteArray.charMap[this.pages[p][i]];
                }
              }
              return rv;
            };
            
            ByteArray.prototype.writeByte = function(val) {
              if (this.cursor >= ByteArray.pageSize) this.newPage();
              this.pages[this.page][this.cursor++] = val;
            };
            
            ByteArray.prototype.writeUTFBytes = function(string) {
              for (var l = string.length, i = 0; i < l; i++)
                this.writeByte(string.charCodeAt(i));
            };
            
            ByteArray.prototype.writeBytes = function(array, offset, length) {
              for (var l = length || array.length, i = offset || 0; i < l; i++)
                this.writeByte(array[i]);
            };
            
            function GIFEncoder(width, height) {
              this.width = ~~width;
              this.height = ~~height;
              this.transparent = null;
              this.transIndex = 0;
              this.repeat = -1;
              this.delay = 0;
              this.image = null;
              this.pixels = null;
              this.indexedPixels = null;
              this.colorDepth = null;
              this.colorTab = null;
              this.usedEntry = new Array();
              this.palSize = 7;
              this.dispose = -1;
              this.firstFrame = true;
              this.sample = 10;
              this.out = new ByteArray();
            }
            
            GIFEncoder.prototype.setDelay = function(milliseconds) {
              this.delay = Math.round(milliseconds / 10);
            };
            
            GIFEncoder.prototype.setFrameRate = function(fps) {
              this.delay = Math.round(100 / fps);
            };
            
            GIFEncoder.prototype.setDispose = function(disposalCode) {
              if (disposalCode >= 0) this.dispose = disposalCode;
            };
            
            GIFEncoder.prototype.setRepeat = function(repeat) {
              this.repeat = repeat;
            };
            
            GIFEncoder.prototype.setTransparent = function(color) {
              this.transparent = color;
            };
            
            GIFEncoder.prototype.addFrame = function(imageData) {
              this.image = imageData;
              this.getImagePixels();
              this.analyzePixels();
              if (this.firstFrame) {
                this.writeLSD();
                this.writePalette();
                if (this.repeat >= 0) {
                  this.writeNetscapeExt();
                }
              }
              this.writeGraphicCtrlExt();
              this.writeImageDesc();
              if (!this.firstFrame && !this.globalPalette) this.writePalette();
              this.writePixels();
              this.firstFrame = false;
            };
            
            GIFEncoder.prototype.finish = function() {
              this.out.writeByte(0x3b);
            };
            
            GIFEncoder.prototype.setQuality = function(quality) {
              if (quality < 1) quality = 1;
              this.sample = quality;
            };
            
            GIFEncoder.prototype.writeHeader = function() {
              this.out.writeUTFBytes("GIF89a");
            };
            
            GIFEncoder.prototype.writeNetscapeExt = function() {
              this.out.writeByte(0x21); // extension introducer
              this.out.writeByte(0xff); // app extension label
              this.out.writeByte(11);   // block size
              this.out.writeUTFBytes("NETSCAPE2.0"); // app id + auth code
              this.out.writeByte(3);    // sub-block size
              this.out.writeByte(1);    // loop sub-block id
              this.writeShort(this.repeat); // loop count (0 = inf)
              this.out.writeByte(0);    // block terminator
            };
            
            GIFEncoder.prototype.analyzePixels = function() {
              const w = this.width;
              const h = this.height;
              this.pixels = new Uint8Array(w * h * 4); // Changed to 4 components (RGBA)
              const data = this.image;
              let count = 0;
              
              // Copy RGBA values
              for (let i = 0; i < h; i++) {
                for (let j = 0; j < w; j++) {
                  const b = i * w * 4 + j * 4;
                  this.pixels[count++] = data[b];     // R
                  this.pixels[count++] = data[b + 1]; // G
                  this.pixels[count++] = data[b + 2]; // B
                  this.pixels[count++] = data[b + 3]; // A
                }
              }
              
              // Create color map with transparency
              const map = {};
              const palette = [];
              let colorCount = 0;
              
              // Reserve first color for transparency
              map['transparent'] = 0;
              palette.push([0, 0, 0, 0]); // Transparent color
              colorCount = 1;
              
              // Find unique colors (up to 255, since index 0 is reserved for transparency)
              for (let i = 0; i < this.pixels.length; i += 4) {
                const r = this.pixels[i];
                const g = this.pixels[i + 1];
                const b = this.pixels[i + 2];
                const a = this.pixels[i + 3];
                
                // Skip fully transparent pixels
                if (a < 128) continue;
                
                const key = (r << 16) | (g << 8) | b;
                
                if (map[key] === undefined && colorCount < 256) {
                  map[key] = colorCount;
                  palette.push([r, g, b, 255]); // Store as opaque
                  colorCount++;
                }
              }
              
              // Fill remaining palette entries with black
              while (palette.length < 256) {
                palette.push([0, 0, 0, 255]);
              }
              
              // Create indexed pixels
              const len = this.pixels.length / 4;
              this.indexedPixels = new Uint8Array(len);
              
              // Map pixels to palette indices
              for (let i = 0; i < len; i++) {
                const r = this.pixels[i * 4];
                const g = this.pixels[i * 4 + 1];
                const b = this.pixels[i * 4 + 2];
                const a = this.pixels[i * 4 + 3];
                
                // Use transparent index for transparent pixels
                if (a < 128) {
                  this.indexedPixels[i] = 0;
                  continue;
                }
                
                const key = (r << 16) | (g << 8) | b;
                this.indexedPixels[i] = map[key] || 0;
              }
              
              // Create color table
              this.colorTab = new Uint8Array(palette.length * 3);
              for (let i = 0; i < palette.length; i++) {
                const color = palette[i];
                this.colorTab[i * 3] = color[0];
                this.colorTab[i * 3 + 1] = color[1];
                this.colorTab[i * 3 + 2] = color[2];
              }
              
              this.pixels = null;
              this.colorDepth = 8;
              this.palSize = 7;
              this.transparent = 0; // Set transparent color index
            };
            
            GIFEncoder.prototype.writeLSD = function() {
              this.writeShort(this.width);
              this.writeShort(this.height);
              this.out.writeByte(0x80 | 0x70 | 0x00 | this.palSize);
              this.out.writeByte(0);
              this.out.writeByte(0);
            };
            
            GIFEncoder.prototype.writeGraphicCtrlExt = function() {
              this.out.writeByte(0x21);
              this.out.writeByte(0xf9);
              this.out.writeByte(4);
              let transp, disp;
              if (this.transparent === null) {
                transp = 0;
                disp = 0;
              } else {
                transp = 1;
                disp = 2;
              }
              if (this.dispose >= 0) {
                disp = dispose & 7;
              }
              disp <<= 2;
              this.out.writeByte(0 | disp | 0 | transp);
              this.writeShort(this.delay);
              this.out.writeByte(this.transIndex);
              this.out.writeByte(0);
            };
            
            GIFEncoder.prototype.writeImageDesc = function() {
              this.out.writeByte(0x2c);
              this.writeShort(0);
              this.writeShort(0);
              this.writeShort(this.width);
              this.writeShort(this.height);
              if (this.firstFrame || this.globalPalette) {
                this.out.writeByte(0);
              } else {
                this.out.writeByte(0x80 | 0 | 0 | 0 | this.palSize);
              }
            };
            
            GIFEncoder.prototype.writePalette = function() {
              this.out.writeBytes(this.colorTab);
              const n = (3 * 256) - this.colorTab.length;
              for (let i = 0; i < n; i++)
                this.out.writeByte(0);
            };
            
            GIFEncoder.prototype.writeShort = function(pValue) {
              this.out.writeByte(pValue & 0xFF);
              this.out.writeByte((pValue >> 8) & 0xFF);
            };
            
            GIFEncoder.prototype.writePixels = function() {
              const enc = new LZWEncoder(this.width, this.height, this.indexedPixels, 8);
              enc.encode(this.out);
            };
            
            GIFEncoder.prototype.stream = function() {
              return this.out;
            };
            
            GIFEncoder.prototype.getImagePixels = function() {
              const w = this.width;
              const h = this.height;
              this.pixels = new Uint8Array(w * h * 3);
              const data = this.image;
              let count = 0;
              
              for (let i = 0; i < h; i++) {
                for (let j = 0; j < w; j++) {
                  const b = i * w * 4 + j * 4;
                  this.pixels[count++] = data[b];
                  this.pixels[count++] = data[b + 1];
                  this.pixels[count++] = data[b + 2];
                }
              }
            };
            
            function LZWEncoder(width, height, pixels, colorDepth) {
              const initCodeSize = Math.max(2, colorDepth);
              const EOF = -1;
              const BITS = 12;
              const HSIZE = 5003;
              const accum = new Uint8Array(256);
              const htab = new Int32Array(HSIZE);
              const codetab = new Int32Array(HSIZE);
              let cur_accum, cur_bits = 0;
              let a_count;
              let free_ent = 0;
              let maxcode;
              let clear_flg = false;
              let g_init_bits, ClearCode, EOFCode;
              
              function char_out(c, outs) {
                accum[a_count++] = c;
                if (a_count >= 254)
                  flush_char(outs);
              }
              
              function flush_char(outs) {
                if (a_count > 0) {
                  outs.writeByte(a_count);
                  outs.writeBytes(accum, 0, a_count);
                  a_count = 0;
                }
              }
              
              function cl_block(outs) {
                cl_hash(HSIZE);
                free_ent = ClearCode + 2;
                clear_flg = true;
                output(ClearCode, outs);
              }
              
              function cl_hash(hsize) {
                for (var i = 0; i < hsize; ++i)
                  htab[i] = -1;
              }
              
              function compress(init_bits, outs) {
                var fcode, c, i, ent, disp, hsize_reg, hshift;
                g_init_bits = init_bits;
                clear_flg = false;
                n_bits = g_init_bits;
                maxcode = MAXCODE(n_bits);
                ClearCode = 1 << (init_bits - 1);
                EOFCode = ClearCode + 1;
                free_ent = ClearCode + 2;
                a_count = 0;
                ent = nextPixel();
                hshift = 0;
                for (fcode = HSIZE; fcode < 65536; fcode *= 2)
                  ++hshift;
                hshift = 8 - hshift;
                hsize_reg = HSIZE;
                cl_hash(hsize_reg);
                output(ClearCode, outs);
                outer_loop: while ((c = nextPixel()) != EOF) {
                  fcode = (c << BITS) + ent;
                  i = (c << hshift) ^ ent;
                  if (htab[i] === fcode) {
                    ent = codetab[i];
                    continue;
                  } else if (htab[i] >= 0) {
                    disp = hsize_reg - i;
                    if (i === 0)
                      disp = 1;
                    do {
                      if ((i -= disp) < 0)
                        i += hsize_reg;
                      if (htab[i] === fcode) {
                        ent = codetab[i];
                        continue outer_loop;
                      }
                    } while (htab[i] >= 0);
                  }
                  output(ent, outs);
                  ent = c;
                  if (free_ent < (1 << BITS)) {
                    codetab[i] = free_ent++;
                    htab[i] = fcode;
                  } else {
                    cl_block(outs);
                  }
                }
                output(ent, outs);
                output(EOFCode, outs);
              }
              
              function encode(outs) {
                outs.writeByte(initCodeSize);
                remaining = width * height;
                curPixel = 0;
                compress(initCodeSize + 1, outs);
                outs.writeByte(0);
              }
              
              function MAXCODE(n_bits) {
                return (1 << n_bits) - 1;
              }
              
              function nextPixel() {
                if (remaining === 0)
                  return EOF;
                --remaining;
                var pix = pixels[curPixel++];
                return pix & 0xff;
              }
              
              function output(code, outs) {
                cur_accum &= masks[cur_bits];
                if (cur_bits > 0)
                  cur_accum |= (code << cur_bits);
                else
                  cur_accum = code;
                cur_bits += n_bits;
                while (cur_bits >= 8) {
                  char_out((cur_accum & 0xff), outs);
                  cur_accum >>= 8;
                  cur_bits -= 8;
                }
                if (free_ent > maxcode || clear_flg) {
                  if (clear_flg) {
                    maxcode = MAXCODE(n_bits = g_init_bits);
                    clear_flg = false;
                  } else {
                    ++n_bits;
                    if (n_bits == BITS)
                      maxcode = 1 << BITS;
                    else
                      maxcode = MAXCODE(n_bits);
                  }
                }
                if (code == EOFCode) {
                  while (cur_bits > 0) {
                    char_out((cur_accum & 0xff), outs);
                    cur_accum >>= 8;
                    cur_bits -= 8;
                  }
                  flush_char(outs);
                }
              }
              
              this.encode = encode;
            }
            
            const masks = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];
            
            onmessage = function(e) {
              var encoder = new GIFEncoder(e.data.width, e.data.height);
              if (e.data.index === 0) encoder.writeHeader();
              else encoder.firstFrame = false;
              encoder.setTransparent(e.data.transparent);
              encoder.setRepeat(e.data.repeat);
              encoder.setDelay(e.data.delay);
              encoder.setQuality(e.data.quality);
              encoder.addFrame(e.data.data);
              if (e.data.last) encoder.finish();
              if (e.data.globalPalette === true) e.data.globalPalette = encoder.getGlobalPalette();
              var stream = encoder.stream();
              e.data.data = stream.pages;
              e.data.cursor = stream.cursor;
              e.data.pageSize = stream.constructor.pageSize;
              postMessage(e.data);
            }
          `], { type: 'application/javascript' }))
        });

        // Add each frame with optimized rendering
        for (let i = 0; i < images.length; i++) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.imageSmoothingEnabled = true; // Enable image smoothing
          ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(images[i], 0, 0);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          gif.addFrame(imageData, { 
            delay: frameDelay,
            copy: true,
            dispose: 2 // Use dispose mode 2 for smoother transitions
          });
          updateStatus(`Adding frame ${i + 1}/${images.length}...`);
        }

        // Render GIF with progress tracking
        gif.on('progress', p => updateStatus(`Rendering: ${Math.round(p * 100)}%`));
        
        gif.on('finished', blob => {
          const url = URL.createObjectURL(blob);
          const preview = document.getElementById('preview');
          preview.innerHTML = `
            <img src="${url}" alt="Generated GIF">
            <br>
            <a href="${url}" download="animation.gif" class="download-link">Download GIF</a>
          `;
          updateStatus('GIF created successfully!');
        });

        gif.render();
        
      } catch (error) {
        console.error('Error creating GIF:', error);
        updateStatus('Error: ' + error.message, true);
      }
    }

    async function createMp4(frames, isWebM = false) {
      try {
        updateStatus(`Creating ${isWebM ? 'WebM' : 'MP4'}...`);
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const frameDelay = parseInt(document.getElementById('frameDelay').value) || 500;
        const fps = Math.round(1000 / frameDelay);
        const quality = parseFloat(document.getElementById(isWebM ? 'webmQuality' : 'mp4Quality').value) || 4;
        
        // Load all images first with high-quality settings
        const images = await Promise.all(frames.map((frame, index) => {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error(`Failed to load frame ${index + 1}`));
            img.src = 'data:image/png;base64,' + frame;
          });
        }));
        
        if (images.length === 0) {
          throw new Error('No frames loaded');
        }

        // Set canvas size to first frame
        canvas.width = images[0].width;
        canvas.height = images[0].height;

        // Create MediaRecorder with optimized settings
        const stream = canvas.captureStream(Math.min(60, Math.max(30, fps))); // Cap FPS between 30-60
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: isWebM ? 'video/webm;codecs=vp9' : 'video/webm',
          videoBitsPerSecond: quality * 1000000 // Convert Mbps to bps
        });

        const chunks = [];
        mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
        mediaRecorder.onstop = async () => {
          const blob = new Blob(chunks, { type: isWebM ? 'video/webm' : 'video/mp4' });
          const url = URL.createObjectURL(blob);
          const preview = document.getElementById('preview');
          preview.innerHTML = `
            <video controls style="max-width: 100%; border-radius: 4px; background: ${isWebM ? 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAASdEVYdFRpdGxlAFBhcGVyIFNoZWV0c7mvkfkAAAAXdEVYdEF1dGhvcgBMYXBvIENhbGFtYW5kcmVp35EaKgAAACl0RVh0RGVzY3JpcHRpb24AQmFzZWQgb2YgSmFrdWIgU3RlaW5lciBkZXNpZ26ghAVzAAABbElEQVQ4jYWTv0vDQBTHv3dJqrQqiFtFxD+gk0MHF/8EF9HN2cXVyUHE2U3BQZykIDhJcRRcpLiIOEhxkEA3kSoo/qqgH5eXd7ocNgm1OvS9y3vv+73jHvfIaK1hix1ryHgBTs+HUKkVcHM5/q7HStx8WXX7+2kPgR0QHQ0h+QdHAOpLqTWqfwGTLwXG5kMoBxCxgK4eyDNn+oVwT0UKrJ5NWQAASGWGYXQyxR6A1FwYj7dj1vRvZsLwxwXWVoIWMJ4OYmE9aDG9CwAARpMB7J2PLQC6W/yY2wxbxekzp3y42I2h0yBQyqlpSqUyO5qwADdtg1A5u5qwAO0KjMZ9SMz7oR0BALjak3j+zFnA0V0SJRUHAEgpsXk4ZQGdhYz3vCoDACk5cs8FrB/EUVCc4e2zrOb2K0HyL4iQwuNTwQF0qW5hIZpF/bMEAOh+VRWs51T/BcxLzAIAYPr4Ec0/rzgL+wNQgKWacMXGNwAAAABJRU5ErkJggg==") 0 0, auto' : 'none'};">
            <source src="${url}" type="${isWebM ? 'video/webm' : 'video/mp4'}">
          </video>
          <br>
          <a href="${url}" download="animation.${isWebM ? 'webm' : 'mp4'}" class="download-link">Download ${isWebM ? 'WebM' : 'MP4'}</a>
        `;
        updateStatus(`${isWebM ? 'WebM' : 'MP4'} created successfully!`);
      };

      mediaRecorder.start();

      // Draw frames with precise timing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      const startTime = performance.now();
      let frameIndex = 0;
      let lastFrameDrawn = false;

      function drawNextFrame() {
        if (frameIndex >= images.length && !lastFrameDrawn) {
          // Draw the last frame one more time to ensure it's visible
          lastFrameDrawn = true;
          setTimeout(() => {
            mediaRecorder.stop();
          }, frameDelay);
          return;
        }

        if (lastFrameDrawn) return;

        const expectedTime = startTime + frameIndex * frameDelay;
        const currentTime = performance.now();
        const deltaTime = expectedTime - currentTime;

        if (deltaTime <= 0) {
          // Draw frame
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(images[frameIndex], 0, 0);
          updateStatus(`Processing frame ${frameIndex + 1}/${images.length}...`);
          frameIndex++;
          requestAnimationFrame(drawNextFrame);
        } else {
          // Wait for the right time to draw
          setTimeout(() => requestAnimationFrame(drawNextFrame), deltaTime);
        }
      }

      requestAnimationFrame(drawNextFrame);

    } catch (error) {
      console.error('Error creating video:', error);
      updateStatus('Error: ' + error.message, true);
    }
  }

  async function createLottie(frames) {
    try {
      updateStatus('Creating Lottie animation...');
      
      const frameDelay = parseInt(document.getElementById('frameDelay').value) || 500;
      const version = document.getElementById('lottieVersion').value;
      const fps = Math.round(1000 / frameDelay);
      
      // Load all images
      const images = await Promise.all(frames.map((frame, index) => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error(`Failed to load frame ${index + 1}`));
          img.src = 'data:image/png;base64,' + frame;
        });
      }));
      
      if (images.length === 0) {
        throw new Error('No frames loaded');
      }

      // Create canvas for image processing
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = images[0].width;
      canvas.height = images[0].height;

      // Create Lottie JSON structure
      const lottieData = {
        v: version,
        fr: fps,
        ip: 0,
        op: images.length,
        w: canvas.width,
        h: canvas.height,
        nm: "Figma Animation",
        ddd: 0,
        assets: [],
        layers: []
      };

      // Process each frame
      for (let i = 0; i < images.length; i++) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(images[i], 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Convert frame to base64
        const frameBase64 = canvas.toDataURL('image/png');
        
        // Add to assets
        lottieData.assets.push({
          id: `image_${i}`,
          w: canvas.width,
          h: canvas.height,
          u: "",
          p: frameBase64,
          e: 1
        });

        // Add layer for this frame
        lottieData.layers.push({
          ddd: 0,
          ind: i + 1,
          ty: 2,
          nm: `Frame ${i + 1}`,
          sr: 1,
          ks: {
            o: { a: 0, k: 100 },
            r: { a: 0, k: 0 },
            p: { a: 0, k: [canvas.width / 2, canvas.height / 2] },
            a: { a: 0, k: [canvas.width / 2, canvas.height / 2, 0] },
            s: { a: 0, k: [100, 100] }
          },
          ao: 0,
          ip: i,
          op: i + 1,
          st: i,
          bm: 0,
          refId: `image_${i}`
        });

        updateStatus(`Processing frame ${i + 1}/${images.length}...`);
      }

      // Create download link
      const blob = new Blob([JSON.stringify(lottieData)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      // Create preview using lottie-web
      const preview = document.getElementById('preview');
      preview.innerHTML = `
        <div id="lottie-preview" style="width: 100%; max-width: 500px; margin: 0 auto;"></div>
        <br>
        <a href="${url}" download="animation.json" class="download-link">Download Lottie JSON</a>
      `;

      // Load lottie-web script dynamically
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.7.14/lottie.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });

      // Initialize Lottie preview
      lottie.loadAnimation({
        container: document.getElementById('lottie-preview'),
        renderer: 'svg',
        loop: true,
        autoplay: true,
        animationData: lottieData
      });

      updateStatus('Lottie animation created successfully!');
      
    } catch (error) {
      console.error('Error creating Lottie:', error);
      updateStatus('Error: ' + error.message, true);
    }
  }

  // Initialize UI when document is ready
  document.addEventListener('DOMContentLoaded', () => {
    const refresh = document.getElementById('refresh');
    const convert = document.getElementById('convert');
    
    if (refresh) {
      refresh.onclick = () => {
        console.log('Refresh button clicked');
        parent.postMessage({ pluginMessage: { type: 'refresh-frames' } }, '*');
      };
    }
    
    if (convert) {
      convert.onclick = () => {
        console.log('Convert button clicked');
        if (!selectedFrames || selectedFrames.length === 0) {
          updateStatus('Please select frames first', true);
          return;
        }

        const format = document.querySelector('input[name="format"]:checked').value;
        const frameDelay = parseInt(document.getElementById('frameDelay').value) || 500;
        console.log('Converting frames to', format, 'with delay:', frameDelay);
        
        parent.postMessage({
          pluginMessage: {
            type: 'convert',
            frameIds: selectedFrames.map(f => f.id),
            frameDelay: frameDelay,
            format: format
          }
        }, '*');
        updateStatus('Starting conversion...');
      };
    }
    
    console.log('UI initialized and ready');
  });

  // Handle messages from the plugin
  window.onmessage = async event => {
    console.log('Received message:', event.data);
    
    const msg = event.data.pluginMessage;
    if (!msg) return;

    if (msg.type === 'frame-list') {
      updateFramesList(msg.frames);
    } else if (msg.type === 'frame-images') {
      try {
        const format = document.querySelector('input[name="format"]:checked').value;
        if (format === 'gif') {
          await createGif(msg.images);
        } else if (format === 'mp4') {
          await createMp4(msg.images, false);
        } else if (format === 'webm') {
          await createMp4(msg.images, true);
        } else if (format === 'lottie') {
          await createLottie(msg.images);
        }
      } catch (error) {
        console.error('Error:', error);
        updateStatus('Error: ' + error.message, true);
      }
    } else if (msg.type === 'error') {
      updateStatus(msg.message, true);
    }
  };

  function updateFormatSettings() {
    const format = document.querySelector('input[name="format"]:checked').value;
    document.querySelectorAll('.format-settings').forEach(el => el.classList.add('hidden'));
    document.getElementById(`${format}-settings`).classList.remove('hidden');
  }
</script>
</head>
<body>
  <div id="frames-list">
    <div class="frame-item">No frames selected</div>
  </div>

  <div class="export-options">
    <div class="export-option">
      <input type="radio" id="gif" name="format" value="gif" checked onchange="updateFormatSettings()">
      <label for="gif">GIF</label>
    </div>
    
    <div class="export-option">
      <input type="radio" id="mp4" name="format" value="mp4" onchange="updateFormatSettings()">
      <label for="mp4">MP4 (No Transparency)</label>
    </div>

    <div class="export-option">
      <input type="radio" id="webm" name="format" value="webm" onchange="updateFormatSettings()">
      <label for="webm">WebM (With Transparency)</label>
    </div>

    <div class="export-option">
      <input type="radio" id="lottie" name="format" value="lottie" onchange="updateFormatSettings()">
      <label for="lottie">Lottie (JSON)</label>
    </div>

    <div id="gif-settings" class="format-settings">
      <div>
        <label>Frame Delay (ms): </label>
        <input type="number" id="frameDelay" value="500" min="100" max="2000" style="width: 60px">
      </div>
    </div>

    <div id="mp4-settings" class="format-settings hidden">
      <div>
        <label>Frame Delay (ms): </label>
        <input type="number" id="frameDelay" value="500" min="100" max="2000" style="width: 60px">
      </div>
      <div>
        <label>Quality (Mbps): </label>
        <input type="number" id="mp4Quality" value="4" min="1" max="10" step="0.5" style="width: 60px">
      </div>
    </div>

    <div id="webm-settings" class="format-settings hidden">
      <div>
        <label>Frame Delay (ms): </label>
        <input type="number" id="frameDelay" value="500" min="100" max="2000" style="width: 60px">
      </div>
      <div>
        <label>Quality (Mbps): </label>
        <input type="number" id="webmQuality" value="4" min="1" max="10" step="0.5" style="width: 60px">
      </div>
    </div>

    <div id="lottie-settings" class="format-settings hidden">
      <div>
        <label>Frame Delay (ms): </label>
        <input type="number" id="frameDelay" value="500" min="100" max="2000" style="width: 60px">
      </div>
      <div>
        <label>Version: </label>
        <select id="lottieVersion" style="width: 100px">
          <option value="5.5.7">5.5.7 (Stable)</option>
          <option value="5.7.1">5.7.1 (Latest)</option>
        </select>
      </div>
    </div>
  </div>

  <button id="refresh">Refresh Frames</button>
  <button id="convert" disabled>Convert</button>
  <div id="preview"></div>
  <div id="status"></div>
</body>
</html> 